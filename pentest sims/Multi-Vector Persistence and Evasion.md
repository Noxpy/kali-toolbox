# Lab: Multi-Vector Persistence and Evasion

## Estimated time needed: 30 minutes

### Overview
Adversaries often use redundant persistence mechanisms combined with anti-forensic techniques to remain hidden. In real environments, they may plant startup scripts, manipulate file timestamps (timestomping), or scatter decoys to mislead defenders. This lab simulates those tactics, giving you the opportunity to create multiple persistence vectors and apply timestomping to evade detection. Defenders who understand these techniques are better prepared to hunt for subtle signs of long-term compromise.

In this lab, you will simulate how adversaries establish redundant persistence vectors and attempt to hide their tracks through anti-forensic techniques such as timestomping. Instead of backdoors or shells, you will safely deploy benign artifacts that mimic attacker tradecraft while writing only to local logs.

**Safety Note**: This lab is strictly educational. No reverse shells or network callbacks are used. All actions remain on the host and produce auditable local artifacts.

### Learning Objectives
After completing this lab, you will be able to:
- Implement multiple persistence vectors on a Linux system
- Apply timestomping to simulate anti-forensic evasion
- Validate persistence activity through log entries after reboot/login
- Investigate suspicious files with detection commands

---

## Exercise 0: Pre-lab Setup

1. **Ensure you already have a primary persistence vector from the previous lab (cron job). If not, create one on the metasploitable2 VM/image quickly:**

   Replace `<MSF_IP>` with the Metasploitable2 VM IP (e.g. 192.168.1.49). Password: `msfadmin`

   ```bash
   ssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa msfadmin@<MSF_IP>
   (crontab -l 2>/dev/null; echo '@reboot echo "$(date +%F_%T) [CRON_TRIGGER] user=$(whoami)" >> /var/log/poc/cron-persist.log') | crontab -
   

2. **Confirm the log directory exists:**

   ```bash
   sudo mkdir -p /var/log/poc
   sudo touch /var/log/poc/persist.log
   sudo chmod 644 /var/log/poc/persist.log
   ```

   **Why this step is important:**
   Having two persistence mechanisms (cron and profile.d) simulates redundancy. Logs provide the artifacts you will use to validate activity.

---

## Troubleshooting Exercise: SSH Refused

**Context:** If your SSH attempt to the Metasploitable2 target returns "Connection refused," follow these steps to diagnose and fix the problem. Replace `<container>` and `<container_ip>` with the container name (e.g. `metasploitable2`) and IP (e.g. `172.18.0.2`).

1. **Confirm container status & IP:**

   ```bash
   sudo docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}"
   sudo docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container>
   ```

2. **Check container logs for SSH errors:**

   ```bash
   sudo docker logs <container> --tail 200
   ```

3. **Exec into the container and check SSH:**

   ```bash
   sudo docker exec -it <container> /bin/bash
   ps aux | grep -E 'sshd|ssh'
   ss -tlnp | grep :22 || netstat -tlnp | grep :22
   service ssh start || /etc/init.d/ssh start || /usr/sbin/sshd -D &
   ```

4. **Confirm host-side port mappings:**

   ```bash
   sudo docker port <container>
   sudo docker inspect -f '{{json .NetworkSettings.Ports}}' <container> | jq .
   ```

5. **Re-scan from Kali and test:**

   ```bash
   sudo nmap -Pn -sV -p22 <container_ip>
   nc -v -z <container_ip> 22
   ssh -p 2222 msfadmin@localhost
   ```

6. **If SSH remains refused:**

   * Restart the container: `sudo docker restart <container>`, then repeat Steps 2â€“5.
   * If the container does not expose port 22 on the host, recreate with port mapping:

   ```bash
   sudo docker run -d --name metasploitable2 -p 2222:22 <metasploitable-image>
   ssh -p 2222 msfadmin@localhost
   ```

---

## Exercise 1: Create a Secondary Persistence Vector

1. **Place a benign script in `/etc/profile.d/` that triggers on interactive shell login:**

   ```bash
   sudo bash -c 'cat > /etc/profile.d/.env.sh << "EOF"
   #!/usr/bin/env bash
   SESSION_ID="$(hostname)-$(id -u)-$(stat -c %Y /etc/profile.d/.env.sh 2>/dev/null || echo 0)"
   echo "$(date +%F_%T) [PROFILE_D_TRIGGER] user=$(whoami) tty=${TTY:-none} session=${SESSION_ID}" >> /var/log/poc/persist.log
   EOF'
   ```

2. **Verify contents and permissions:**

   ```bash
   sudo head -n 5 /etc/profile.d/.env.sh
   ls -l /etc/profile.d/.env.sh
   ```

   **Why this step is important:**
   Startup locations like `/etc/profile.d/` are common persistence targets. Here you simulate that behavior with harmless logging.

---

## Exercise 2: Make the Script Executable

1. **Ensure the script can run:**

   ```bash
   sudo chmod +x /etc/profile.d/.env.sh
   ls -l /etc/profile.d/.env.sh
   ```

   **Why this step is important:**
   Scripts in `/etc/profile.d/` only perform if they are marked as executable. Attackers ensure this to guarantee their persistence survives.

---

## Exercise 3: Apply Timestomping

1. **Backdate the script to simulate anti-forensics (e.g., 1 Jan 2022):**

   ```bash
   sudo touch -t 202201010101 /etc/profile.d/.env.sh
   ```

2. **Create a decoy artifact in `/tmp` and timestomp it as well:**

   ```bash
   sudo bash -c 'echo "# harmless decoy updater" > /tmp/.update.sh'
   sudo chmod +x /tmp/.update.sh
   sudo touch -t 202201010101 /tmp/.update.sh
   ```

3. **Verify the timestamps:**

   ```bash
   stat /etc/profile.d/.env.sh
   stat /tmp/.update.sh
   ls -l --time-style=full-iso /etc/profile.d/.env.sh /tmp/.update.sh
   ```

   **Why this step is important:**
   Timestomping hides malicious files by making them appear older. As defenders, you must corroborate with hashes and logs.

---

## Exercise 4: Validate Persistence After Reboot

1. **Reboot the system:**

   ```bash
   sudo reboot
   # wait a minute and log in again
   ssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa msfadmin@192.168.1.49
   ```

2. **Trigger the profile.d script by starting a login shell:**

   ```bash
   bash -l
   ```

3. **Validate the log entries:**

   ```bash
   tail -n 10 /var/log/poc/persist.log
   tail -n 10 /var/log/poc/cron-persist.log
   ```

   **Why this step is important:**
   Redundant persistence ensures that at least one vector survives defensive cleanup. Validation confirms both paths executed successfully.

---

## Exercise 5: Evasion and Detection

1. **Detect suspicious executables in `/etc/profile.d/`:**

   ```bash
   sudo find /etc/profile.d -type f -perm -111 -printf '%TY-%Tm-%Td %TH:%TM %p\n'
   ```

2. **Collect metadata and hashes:**

   ```bash
   stat /etc/profile.d/.env.sh
   sha256sum /etc/profile.d/.env.sh
   ```

3. **Check package ownership (not normally present):**

   ```bash
   dpkg -S /etc/profile.d/.env.sh || echo "Not owned by any package"
   ```

   **Why this step is important:**
   Attackers attempt to blend in with legitimate files. Defenders use hashing, package checks, and behavioral indicators to detect anomalies.

---

## Exercise 6: Cleanup (Optional)

1. **Remove persistence artifacts and logs if cleanup is required:**

   ```bash
   sudo rm -f /etc/profile.d/.env.sh /tmp/.update.sh
   sudo rm -f /var/log/poc/persist.log /var/log/poc/cron-persist.log
   sudo rmdir /var/log/poc 2>/dev/null || true
   crontab -r
   ```
